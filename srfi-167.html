<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>SRFI 167: Ordered Key Value Store</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png" />
  </head>
  <body>

    <h1>Title</h1>

    <p>SRFI 167: Ordered Key Value Store</p>

    <h1>Author</h1>

    <p>Amirouche Boubekki</p>

    <h1>Status</h1>

    <p>This SRFI is currently in <em>draft</em> status.  Here is <a
    href="https://srfi.schemers.org/srfi-process.html">an
    explanation</a> of each status that a SRFI can hold.  To provide
    input on this SRFI, please send email to <code><a
    href="mailto:srfi+minus+167+at+srfi+dotschemers+dot+org">srfi-167@<span
    class="antispam">nospam</span>srfi.schemers.org</a></code>.  To
    subscribe to the list, follow <a
    href="https://srfi.schemers.org/srfi-list-subscribe.html">these
    instructions</a>.  You can access previous messages via the
    mailing list <a
    href="https://srfi-email.schemers.org/srfi-167">archive</a>.</p>

    <ul>
      <li>Received: 2019/4/13</li>
      <li>60-day deadline: 2019/6/17</li>
      <li>Draft #1 published: 2019/4/18</li>
      <li>Draft #2 published: 2019/4/26</li>
      <li>Draft #3 published: 2019/6/2</li>
    </ul>

    <h1>Abstract</h1>

    <p>This library describes an interface for an ordered key-value
      store that is suitable for implementing a storage engine for the
      generic tuple-store SRFI.  It maps cleanly to existing ordered
      key-value databases that may or may not provide transactions.</p>

    <h1>Rationale</h1>

    <p>Ordered key-value stores offer a powerful set of simple and
      elegant primitives to build database abstractions, also
      sometimes called layers.  The
      <a href="https://srfi.schemers.org/srfi-168/">generic tuple store SRFI</a>
      is an example of such abstraction, and others are possible.  A
      standard interface for such databases will allow more people to
      experiment with databases in Scheme.</p>

    <p>While it has not been Scheme's forte to power databases, the
       recent appearance of several ordered key-value stores make the
       idea of building databases with Scheme more applicable as the
       performance concerns are solved by lower-level languages.</p>

    <p>The author argues that getting started with data management
       systems with ordered key-value stores is easier to the
       mind and also reflects the modern industrial practice that
       builds (distributed) databases systems possibly with SQL
       support on top of ordered key-value stores. Otherwise said,
       this SRFI should offer grounds for apprentices to learn
       about data storage.  It will also offer a better story
       (the best?) for data durability in Scheme implementations.</p>

    <p>This SRFI does not overlap with existing SRFIs and complements
       <a href="https://srfi.schemers.org/srfi-168/">generic tuple
       store SRFI</a>.</p>

    <h1>Specification</h1>
    <h2 id="okvs-and-transaction">Okvs and Transaction</h2>

    <p>A okvs is a mapping that may or may not support
      transactions.  Keys are lexicographically ordered bytevectors.
      Values are bytevectors.</p>

    <p>The following specification defines two disjoint types:</p>
    <ul>
      <li><code>okvs</code> is a handle to the data storage</li>
      <li><code>transaction</code> is a handle to a currently running
        transaction</li>
    </ul>

    <p>In the following, <code>CONFIG</code> is always an optional
        parameter that is an association list.  Some configuration
        options are specified to ease portability.  If an
        implementation doesn't recognize an option, it must be
        ignored. Default values are implementation dependent. It is an
        error if this argument is not an association list.</p>

    <h3 id="okvs"><code>(okvs home create? [config])</code></h3>

    <p>Return an okvs object.</p>

    <p><code>HOME</code> describes the the location of the database.  It can be
        an address or a directory.</p>

    <p><code>CREATE?</code> is boolean that specify whether to create
    the database if it does not exist.</p>

    <p><code>CONFIG</code> might contain the following options:</p>

    <table>
        <thead>
            <tr>
                <th>key</th>
                <th>description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>'cache</code></td>
                <td>an integer describing cache size in bytes.</td>
            </tr>
            <tr>
                <td><code>'memory?</code></td>
                <td>whether to keep data only in memory.</td>
            </tr>
            <tr>
                <td><code>'wal?</code></td>
                <td>whether to enable write-ahead-log.</td>
            </tr>
            <tr>
                <td><code>'read-only?</code></td>
                <td>whether to open the database in read-only mode.</td>
            </tr>
        </tbody>
    </table>

    <h3 id="okvs-predicate"><code>(okvs? obj)</code></h3>

    <p>Return <code>#t</code> if <code>OBJ</code> is a <code>okvs</code>,
        and <code>#f</code> otherwise.

        <h3 id="okvs-close-okvs-config"><code>(okvs-close okvs [config])</code></h3>

        <p>Close <code>OKVS</code>. <code>CONFIG</code> is optional.  In the
            case where it is provided, it must be an association list. It is
            implementation dependent.</p>

        <p>No <code>CONFIG</code> options are specified.  An
            implementation may or may not support some implementation
            specific options.</p>

    <h3 id="okvs-debug"><code>(okvs-debug okvs proc)</code></h3>

    <p>Call <code>PROC</code> in lexicographic order for all key-value
        pairs found in <code>OKVS</code>.</p>

    <h3 id="okvs-transaction-begin"><code>(okvs-transaction-begin okvs [config])</code></h3>

    <p>Start a transaction and return a transaction object. The transaction must
        be associated with a newly created hash-table with the default comparator.</p>

    <p>Every transaction must be commited or roll-backed.</p>

    <p>No <code>CONFIG</code> options are specified.  An
        implementation may or may not support some implementation
        specific options.</p>

    <h3 id="okvs-transaction-metadata"><code>(okvs-transaction-metadata transaction)</code></h3>

    <p>Return the hash-table associated with <code>TRANSACTION</code>.</p>

    <h3 id="okvs-transaction"><code>(okvs-transaction? obj)</code></h3>

    <p>Return <code>#t</code> if <code>OBJ</code> is a <code>okvs</code> transaction,
        and <code>#f</code> otherwise.

    <h3 id="okvs-transaction-commit"><code>(okvs-transaction-commit transaction config)</code></h3>

    <p>Commit <code>TRANSACTION</code>.</p>

    <p>No <code>CONFIG</code> options are specified.  An
        implementation may or may not support some implementation
        specific options.</p>

    <h3 id="okvs-transaction-roll-back"><code>(okvs-transaction-roll-back transaction [config])</code></h3>

    <p>Roll back <code>TRANSACTION</code>.</p>

    <p>No <code>CONFIG</code> options are specified.  An
        implementation may or may not support some implementation
        specific options.</p>

    <h3 id="okvs-in-transaction"><code>(okvs-in-transaction okvs proc [failure [success]])</code></h3>

    <p>Start a transaction against <code>OKVS</code> and pass the
        transaction object as argument to <code>PROC</code>. When
        <code>PROC</code> returns, the transaction is commited and
        <code>okvs-in-transaction</code> applies whatever <code>PROC</code>
        returned to the <code>SUCCESS</code> procedure. If <code>PROC</code>
        raises an exception, the transaction is roll-backed and <code>FAILURE</code>
        is called with the exception condition. By default <code>FAILURE</code>
        is <code>raise</code> and <code>SUCCESS</code> is <code>identity</code>.
    </p>

    <h3 id="okvs-ref"><code>(okvs-ref transaction key)</code></h3>

    <p>Return the bytevector associated with <code>KEY</code>
        bytevector using <code>TRANSACTION</code>.  If there is no such
        key, return <code>#f</code>.</p>

    <h3 id="okvs-set"><code>(okvs-set! transaction key value)</code></h3>

    <p>Associate <code>KEY</code> bytevector with <code>VALUE</code>
        bytevector using <code>TRANSACTION</code>.</p>

    <h3 id="okvs-delete"><code>(okvs-delete! transaction key)</code></h3>

    <p>Delete the pair associated with <code>KEY</code> bytevector
        using <code>TRANSACTION</code>.</p>

    <h3 id="okvs-range-remove"><code>(okvs-range-remove! transaction start-key start-include? end-key end-include?)</code></h3>

    <p>Remove all pairs in the specified range.</p>

    <h3 id="okvs-maximum-key"><code>(okvs-maximum-key okvs)</code></h3>

    <p>Returns the largest possible key. It is an error to mutate this key.</p>

    <h3 id="okvs-range"><code>(okvs-range transaction start-key start-include? end-key end-include? [CONFIG])</code></h3>

    <p>Return a SRFI 158 generator of key-value pairs where keys
        are between <code>START-KEY</code> bytevector and <code>END-KEY</code>
        possibly including the boundaries depending on <code>START-INCLUDE?</code>
        and <code>END-INCLUDE?</code>.  The stream must lexicographically
        ordered. <code>CONFIG</code> is optional.</p>

    <p><code>CONFIG</code> might contain the following options:</p>

    <table>
        <thead>
            <tr>
                <th>key</th>
                <th>description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>'limit</code></td>
                <td>indicates the maximum number of key-value pairs to return.</td>
            </tr>
            <tr>
                <td><code>'reverse?</code></td>
                <td>whether key-value pairs will be returned in
                    reverse lexicographical order beginning at the end of
                    the range.</td>
            </tr>
            <tr>
                <td><code>'offset</code></td>
                <td>specify how many keys must be skipped.</td>
            </tr>
        </tbody>
    </table>

    <h3 id="okvs-prefix"><code>(okvs-prefix transaction prefix [CONFIG])</code></h3>

    <p>Return a SRFI 158 generator of key-value pairs where keys
       starts with <code>PREFIX</code> bytevector.  The stream must
       lexicographically ordered.  <code>PREFIX</code> can be the empty
       bytevector, in which case the all the pairs are returned in a
       generator.</p>

    <p><code>CONFIG</code> might contain the following options:</p>
    <table>
        <thead>
            <tr>
                <th>key</th>
                <th>description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td><code>'limit</code></td>
                <td>indicates the maximum number of key-value pairs to return.</td>
            </tr>
            <tr>
                <td><code>'reverse?</code></td>
                <td>whether key-value pairs will be returned in
                    reverse lexicographical order beginning at the end of
                    the range.</td>
            </tr>
            <tr>
                <td><code>'offset</code></td>
                <td>specify how many keys must be skipped.</td>
            </tr>
        </tbody>
    </table>

    <h1>Implementation</h1>

    <p>The <a href="https://srfi.schemers.org/srfi-167/srfi-167.tgz">sample
      implementation</a> relies on scheme mappings (SRFI 146) and
      SRFI-158 generators.</p>

    <h1>Acknowledgements</h1>

    <p>Credits goes to the authors of  <a href="http://www.wiredtiger.com/">WiredTiger</a>
      and <a href="https://www.foundationdb.org/">FoundationDB</a> for
      their work on their respective database engines.  The author
      would like to thank Arthur A. Gleckler and Marc
      Nieper-Wißkirchen for getting together SRFI 146 and Shiro Kawai,
      John Cowan, and Thomas Gilray for their work on SRFI 158.</p>

    <h1>Copyright</h1>

    <p>Copyright (C) Amirouche Boubekki (2019).</p>

    <p>Permission is hereby granted, free of charge, to any person
      obtaining a copy of this software and associated documentation
      files (the “Software”), to deal in the Software without
      restriction, including without limitation the rights to use,
      copy, modify, merge, publish, distribute, sublicense, and/or
      sell copies of the Software, and to permit persons to whom the
      Software is furnished to do so, subject to the following
      conditions:</p>

    <p>The above copyright notice and this permission notice shall be
      included in all copies or substantial portions of the
      Software.</p>

    <p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
      EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
      OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
      NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
      HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
      WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
      OTHER DEALINGS IN THE SOFTWARE.</p>
  </body>
</html>
